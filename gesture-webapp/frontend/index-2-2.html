<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰‹åŠ¿é­”æ³•å±‹ - Gesture Magic Hub</title>
    <style>
        :root {
            --primary-bg: #f0f4f8; --secondary-bg: #ffffff; --text-color: #333;
            --header-bg: #2c3e50; --header-text: #ecf0f1; --accent-color: #3498db;
            --card-shadow: 0 4px 8px rgba(0,0,0,0.1); --border-radius: 8px;
            --success-color: #27ae60; --error-color: #e74c3c; --info-color: #f39c12;
        }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; margin: 0; background-color: var(--primary-bg); color: var(--text-color); line-height: 1.6; }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        header { background-color: var(--header-bg); color: var(--header-text); padding: 20px 0; text-align: center; border-bottom: 4px solid var(--accent-color); }
        header h1 { margin: 0; font-size: 2.5rem; }
        header p { margin: 5px 0 0; font-size: 1.1rem; opacity: 0.9; }
        .main-app { position: relative; display: flex; flex-wrap: wrap; gap: 30px; margin-top: 30px; background: var(--secondary-bg); padding: 20px; border-radius: var(--border-radius); box-shadow: var(--card-shadow); }
        .video-container { flex: 1; min-width: 300px; display: flex; flex-direction: column; align-items: center; }
        .video-container h2 { margin-top: 0; color: var(--accent-color); }
        #video-feed { width: 100%; max-width: 640px; height: auto; border-radius: var(--border-radius); border: 2px solid #ddd; background-color: #000; }
        .result-container { flex: 1; min-width: 300px; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; }
        #status { font-size: 1.2rem; color: #7f8c8d; margin-bottom: 15px; }
        #gesture-label { font-size: 1.5rem; font-weight: bold; }
        #gesture-result { font-size: 8rem; font-weight: bold; color: var(--accent-color); margin: 5px 0; line-height: 1; }
        #action-feedback { font-size: 1.1rem; font-weight: bold; min-height: 25px; margin-top: 10px; transition: color 0.3s ease; }
        .features-section { margin-top: 40px; }
        .category-title { font-size: 2rem; color: var(--header-bg); border-bottom: 2px solid var(--accent-color); padding-bottom: 10px; margin-bottom: 20px; }
        .feature-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(340px, 1fr)); gap: 20px; }
        .feature-card { background-color: var(--secondary-bg); border-radius: var(--border-radius); box-shadow: var(--card-shadow); padding: 25px; transition: all 0.3s ease; border: 2px solid transparent; display: flex; flex-direction: column; }
        .feature-card.active { transform: translateY(-5px); box-shadow: 0 8px 24px rgba(52, 152, 219, 0.4); border-color: var(--accent-color); }
        .feature-card h3 { margin-top: 0; color: var(--accent-color); font-size: 1.5rem; }
        .feature-card p { margin-bottom: 15px; flex-grow: 1; }
        .activate-btn { background-color: var(--accent-color); color: white; border: none; padding: 12px 15px; border-radius: 5px; cursor: pointer; font-size: 1rem; font-weight: bold; margin-top: 15px; width: 100%; transition: background-color 0.3s ease; }
        .activate-btn:hover { background-color: #2980b9; }
        .activate-btn.deactivate { background-color: var(--success-color); }
        footer { text-align: center; padding: 20px; margin-top: 40px; color: #7f8c8d; }

        /* --- NEW: Game Overlay and Canvas --- */
        #game-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(44, 62, 80, 0.85);
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            z-index: 10;
            border-radius: var(--border-radius);
            flex-direction: column;
        }
        #game-canvas {
            background-color: transparent;
            border-radius: var(--border-radius);
        }
        #close-game-btn {
            position: absolute;
            top: 15px; right: 15px;
            background-color: var(--error-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            line-height: 40px;
            text-align: center;
        }
    </style>
</head>
<body>

    <header>
        <h1>æ‰‹åŠ¿é­”æ³•å±‹ - Gesture Magic Hub</h1>
        <p>ä¸€ä¸ªåŸºäºå®æ—¶æ‰‹åŠ¿è¯†åˆ«çš„äº’åŠ¨åº”ç”¨å±•ç¤ºå¹³å°</p>
    </header>

    <div class="container">
        <section class="main-app">
            <!-- NEW: Game Overlay -->
            <div id="game-overlay">
                <canvas id="game-canvas"></canvas>
                <button id="close-game-btn" title="å…³é—­æ¸¸æˆ">X</button>
            </div>

            <div class="video-container">
                <h2>å®æ—¶æ‘„åƒå¤´</h2>
                <img id="video-feed" src="http://127.0.0.1:8000/video_feed" alt="æ­£åœ¨åŠ è½½æ‘„åƒå¤´ç”»é¢...">
            </div>
            <div class="result-container">
                <div id="status">æ­£åœ¨è¿æ¥åˆ°åç«¯...</div>
                <div id="gesture-label">å½“å‰è¯†åˆ«æ‰‹åŠ¿</div>
                <div id="gesture-result">...</div>
                <div id="action-feedback">è¯·ä»ä¸‹æ–¹é€‰æ‹©ä¸€ä¸ªç©æ³•å¹¶æ¿€æ´»</div>
            </div>
        </section>
        
        <section class="features-section">
            <h2 class="category-title">ğŸ® æ¸¸æˆä¸å¨±ä¹ (å·²é‡åˆ¶)</h2>
            <div class="feature-grid">
                <div class="feature-card" data-mode="fruitNinja">
                    <h3>ç©æ³•ä¸€ï¼šæ‰‹åŠ¿ç‰ˆâ€œæ°´æœå¿è€…â€</h3>
                    <p>åœ¨é™å®šæ—¶é—´å†…åšå‡ºå¯¹åº”çš„æ‰‹åŠ¿â€œå‡»ç ´â€æ‰è½çš„ç›®æ ‡ã€‚æ‰‹åŠ¿'0'æ˜¯ç‚¸å¼¹ï¼</p>
                    <button class="activate-btn">æ¿€æ´»æ¸¸æˆ</button>
                </div>
                <div class="feature-card" data-mode="magicSpell">
                    <h3>ç©æ³•ä¸‰ï¼šé­”æ³•å’’è¯­æ–½æ³•</h3>
                    <p>æŒ‰é¡ºåºåšå‡ºæ‰‹åŠ¿ï¼Œç»„åˆæˆä¸€ä¸ªé­”æ³•å’’è¯­ï¼Œè§è¯ç‚«é…·çš„é­”æ³•æ•ˆæœï¼ "7-3-5" (ç«çƒ), "1-2-3-4" (æŠ¤ç›¾)ã€‚</p>
                    <button class="activate-btn">æ¿€æ´»æ¸¸æˆ</button>
                </div>
                 <div class="feature-card" data-mode="rhythmMaster">
                    <h3>ç©æ³•äºŒï¼šæ‰‹åŠ¿â€œèŠ‚å¥å¤§å¸ˆâ€ (å¾…å¼€å‘)</h3>
                    <p>å½“æ–¹å—åˆ°è¾¾æŒ‡å®šåŒºåŸŸæ—¶ï¼Œåšå‡ºç›¸åº”çš„æ‰‹åŠ¿ã€‚ (æ­¤æ¨¡å¼ä¸ºå ä½ç¬¦)</p>
                    <button class="activate-btn" disabled>å¾…å¼€å‘</button>
                </div>
            </div>
            
            <h2 class="category-title" style="margin-top: 40px;">âš™ï¸ æ™ºèƒ½æ§åˆ¶ä¸æ•ˆç‡å·¥å…· (å¾…å¼€å‘)</h2>
            <div class="feature-grid">
                <!-- Other cards are placeholders -->
                <div class="feature-card"><h3 style="color:#95a5a6">ç©æ³•å››ï¼šéæ¥è§¦å¼åª’ä½“æ’­æ”¾å™¨</h3><p>ç”¨æ‰‹åŠ¿æ§åˆ¶åª’ä½“æ’­æ”¾ã€‚</p><button class="activate-btn" disabled>å¾…å¼€å‘</button></div>
                <div class="feature-card"><h3 style="color:#95a5a6">ç©æ³•äº”ï¼šæ¼”ç¤ºæ–‡ç¨¿é¥æ§å™¨</h3><p>ç”¨æ‰‹åŠ¿æ§åˆ¶PPTç¿»é¡µã€‚</p><button class="activate-btn" disabled>å¾…å¼€å‘</button></div>
                <div class="feature-card"><h3 style="color:#95a5a6">ç©æ³•å…­ï¼šæ™ºèƒ½å®¶å±…å¿«æ·æŒ‡ä»¤</h3><p>è”åŠ¨æ™ºèƒ½å®¶å±…è®¾å¤‡ã€‚</p><button class="activate-btn" disabled>å¾…å¼€å‘</button></div>
            </div>
        </section>
    </div>
    
    <footer>
        <p>Â© 2024 Gesture WebApp Project. All ideas presented for demonstration purposes.</p>
    </footer>

        <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- DOM Elements ---
        const statusEl = document.getElementById('status');
        const gestureResultEl = document.getElementById('gesture-result');
        const actionFeedbackEl = document.getElementById('action-feedback');
        const activateBtns = document.querySelectorAll('.activate-btn:not([disabled])');
        const gameOverlay = document.getElementById('game-overlay');
        const gameCanvas = document.getElementById('game-canvas');
        const closeGameBtn = document.getElementById('close-game-btn');

        // --- App State ---
        let appState = {
            ws: null,
            currentMode: null,
            lastGesture: null, // ç”¨äºæ¯”è¾ƒæ‰‹åŠ¿æ˜¯å¦å˜åŒ–
            actionCooldown: false,
            activeGame: null,
        };

        // --- WebSocket Connection ---
        const wsUrl = `ws://${window.location.host}/ws`;
        function connect() {
            appState.ws = new WebSocket(wsUrl);
            appState.ws.onopen = () => {
                statusEl.textContent = 'âœ… å·²è¿æ¥åˆ°åç«¯';
                statusEl.style.color = 'var(--success-color)';
            };
            
            // [FIXED] é‡‡ç”¨æ›´ç¨³å®šå¯é çš„ "å˜åŒ–è§¦å‘" é€»è¾‘
            appState.ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.gesture === undefined) return;
                
                const gesture = data.gesture;
                gestureResultEl.textContent = (gesture === 'Unknown') ? '?' : gesture;
                gestureResultEl.style.color = (gesture === 'Unknown') ? '#95a5a6' : 'var(--accent-color)';

                // æ ¸å¿ƒé€»è¾‘ï¼šä»…å½“æ‰‹åŠ¿å‘ç”Ÿæœ‰æ•ˆå˜åŒ–ï¼Œä¸”ä¸åœ¨å†·å´æœŸæ—¶ï¼Œæ‰è§¦å‘åŠ¨ä½œ
                if (gesture !== 'Unknown' && gesture !== appState.lastGesture && !appState.actionCooldown) {
                    if (appState.currentMode && appState.activeGame) {
                        handleGesture(gesture);
                    }
                    // è§¦å‘åï¼Œè®¾ç½®çŸ­æš‚çš„å†·å´æ—¶é—´ï¼Œé˜²æ­¢æ‰‹åŠ¿æŠ–åŠ¨é€ æˆè¿ç»­è§¦å‘
                    appState.actionCooldown = true;
                    setTimeout(() => { appState.actionCooldown = false; }, 300);
                }
                
                // æ¯ä¸€å¸§éƒ½æ›´æ–°ä¸Šä¸€ä¸ªæ‰‹åŠ¿ï¼Œç”¨äºä¸‹ä¸€å¸§çš„æ¯”è¾ƒ
                appState.lastGesture = gesture;
            };

            // [FIXED] onclose äº‹ä»¶å¤„ç†ç¨‹åºè¢«å¤§å¤§ç®€åŒ–ï¼Œä½¿å…¶æ›´å®‰å…¨
            appState.ws.onclose = () => {
                statusEl.textContent = 'ğŸ”Œ è¿æ¥å·²æ–­å¼€ï¼Œæ­£åœ¨é‡è¿...';
                statusEl.style.color = 'var(--error-color)';
                
                // å¦‚æœå½“å‰æœ‰æ¸¸æˆåœ¨è¿è¡Œï¼Œå®‰å…¨åœ°å…³é—­å®ƒ
                if (appState.currentMode) {
                    deactivateCurrentMode();
                }
                // é‡ç½®çŠ¶æ€
                appState.lastGesture = null;
                appState.ws = null;

                // å®‰å…¨åœ°å®‰æ’é‡è¿
                setTimeout(connect, 3000);
            };
            
            appState.ws.onerror = (error) => {
                console.error("WebSocket Error:", error);
                statusEl.textContent = 'âŒ è¿æ¥å¤±è´¥';
                statusEl.style.color = 'var(--error-color)';
                // è§¦å‘ onclose æ¥å¤„ç†æ¸…ç†å’Œé‡è¿
                if (appState.ws) {
                    appState.ws.close();
                }
            };
        }
        
        // --- Mode Activation Logic ---
        function deactivateCurrentMode() {
            if (!appState.currentMode) return;

            // åœæ­¢å¹¶æ¸…ç†æ¸¸æˆ
            if (appState.activeGame) {
                appState.activeGame.stop();
                appState.activeGame = null;
            }
            gameOverlay.style.display = 'none';

            const activeCard = document.querySelector('.feature-card.active');
            if (activeCard) {
                activeCard.classList.remove('active');
                const btn = activeCard.querySelector('.activate-btn');
                if (btn) { // å®‰å…¨æ£€æŸ¥
                    btn.textContent = 'æ¿€æ´»æ¸¸æˆ';
                    btn.classList.remove('deactivate');
                }
            }
            
            appState.currentMode = null;
            actionFeedbackEl.textContent = 'è¯·ä»ä¸‹æ–¹é€‰æ‹©ä¸€ä¸ªç©æ³•å¹¶æ¿€æ´»';
            actionFeedbackEl.style.color = 'var(--text-color)';
        }

        function activateMode(mode, cardElement) {
            if (appState.currentMode === mode) {
                deactivateCurrentMode();
                return;
            }
            deactivateCurrentMode();
            
            appState.currentMode = mode;
            cardElement.classList.add('active');
            const btn = cardElement.querySelector('.activate-btn');
            btn.textContent = 'æ¸¸æˆä¸­ (ç‚¹å‡»å–æ¶ˆ)';
            btn.classList.add('deactivate');
            actionFeedbackEl.textContent = `æ¨¡å¼ [${cardElement.querySelector('h3').textContent}] å·²æ¿€æ´»ï¼`;

            gameOverlay.style.display = 'flex';
            const mainAppRect = document.querySelector('.main-app').getBoundingClientRect();
            gameCanvas.width = mainAppRect.width;
            gameCanvas.height = mainAppRect.height;

            if (mode === 'fruitNinja') {
                appState.activeGame = new FruitNinjaGame(gameCanvas, deactivateCurrentMode);
            } else if (mode === 'magicSpell') {
                appState.activeGame = new MagicSpellGame(gameCanvas, deactivateCurrentMode);
            }
            if(appState.activeGame) appState.activeGame.start();
        }
        
        activateBtns.forEach(btn => {
            btn.addEventListener('click', (e) => {
                const card = e.target.closest('.feature-card');
                const mode = card.dataset.mode;
                activateMode(mode, card);
            });
        });
        closeGameBtn.addEventListener('click', deactivateCurrentMode);

        function handleGesture(gesture) {
            if (appState.activeGame && typeof appState.activeGame.handleGesture === 'function') {
                appState.activeGame.handleGesture(gesture);
            }
        }
        
        // --- GAME ENGINE AND CLASSES (With Fixes) ---

        class Particle {
            constructor(x, y, color, size, velocity) {
                this.x = x; this.y = y; this.color = color; this.size = Math.abs(size);
                this.velocity = velocity; this.alpha = 1; this.gravity = 0.1; this.friction = 0.99;
            }
            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2, false);
                ctx.fill();
                ctx.restore();
            }
            update() {
                this.velocity.y += this.gravity;
                this.velocity.x *= this.friction;
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.alpha -= 0.02;
            }
        }

        class GameEngine {
            constructor(canvas, onGameOver) {
                this.canvas = canvas; this.ctx = canvas.getContext('2d');
                this.onGameOver = onGameOver; this.gameObjects = [];
                this.particles = []; this.animationFrameId = null;
            }
            start() { this.gameLoop(); }
            stop() { cancelAnimationFrame(this.animationFrameId); }
            gameLoop() {
                this.animationFrameId = requestAnimationFrame(this.gameLoop.bind(this));
                this.update();
                this.draw();
            }
            update() { /* Implemented by child classes */ }
            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.gameObjects.forEach(obj => obj.draw(this.ctx));
                // [FIXED] ä½¿ç”¨å®‰å…¨çš„å€’åºå¾ªç¯æ¥ç§»é™¤ç²’å­ï¼Œé¿å…è·³è¿‡å…ƒç´ 
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    if (p.alpha <= 0) {
                        this.particles.splice(i, 1);
                    } else {
                        p.update();
                        p.draw(this.ctx);
                    }
                }
            }
            createExplosion(x, y, color, count = 20) {
                for (let i = 0; i < count; i++) {
                    const velocity = { x: (Math.random() - 0.5) * 10, y: (Math.random() - 0.5) * 10 };
                    this.particles.push(new Particle(x, y, color, Math.random() * 4 + 1, velocity));
                }
            }
        }

        class Fruit {
            constructor(x, y, radius, color, velocity, text) {
                this.x = x; this.y = y; this.radius = radius; this.color = color;
                this.velocity = velocity; this.text = text;
            }
            draw(ctx) {
                ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
                ctx.fillStyle = this.color; ctx.fill();
                ctx.fillStyle = 'white'; ctx.font = `bold ${this.radius}px Arial`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(this.text, this.x, this.y);
            }
            update() { this.x += this.velocity.x; this.y += this.velocity.y; }
        }

        class FruitNinjaGame extends GameEngine {
            constructor(canvas, onGameOver) {
                super(canvas, onGameOver);
                this.score = 0; this.timer = 60;
                this.spawnInterval = 1000; this.lastSpawn = -1;
                this.colors = ['#e74c3c', '#f1c40f', '#2ecc71', '#3498db', '#9b59b6', '#1abc9c'];
                this.gameTimerId = null; // [FIXED] ç”¨äºå­˜å‚¨è®¡æ—¶å™¨ID
            }

            // [FIXED] å°† setInterval ç§»åˆ° start æ–¹æ³•ä¸­
            start() {
                super.start();
                this.gameTimerId = setInterval(() => {
                    if (this.timer > 0) {
                        this.timer--;
                    } else {
                        this.endGame();
                    }
                }, 1000);
            }
            
            // [FIXED] åœ¨ stop æ–¹æ³•ä¸­æ¸…é™¤è®¡æ—¶å™¨ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼
            stop() {
                super.stop();
                clearInterval(this.gameTimerId);
            }

            update() {
                const now = Date.now();
                if (now - this.lastSpawn > this.spawnInterval) {
                    this.lastSpawn = now;
                    this.spawnFruit();
                }
                this.gameObjects.forEach((fruit, index) => {
                    fruit.update();
                    if (fruit.y > this.canvas.height + fruit.radius) {
                        this.gameObjects.splice(index, 1);
                    }
                });
            }

            draw() {
                super.draw();
                this.gameObjects.forEach(obj => obj.draw(this.ctx));
                this.ctx.fillStyle = 'white'; this.ctx.font = 'bold 32px Arial';
                this.ctx.textAlign = 'left'; this.ctx.fillText(`Score: ${this.score}`, 20, 40);
                this.ctx.textAlign = 'right'; this.ctx.fillText(`Time: ${this.timer}`, this.canvas.width - 20, 40);
            }

            spawnFruit() {
                const radius = Math.random() * 20 + 30;
                const x = Math.random() * (this.canvas.width - 2 * radius) + radius;
                const y = -radius; const velocity = { x: 0, y: Math.random() * 2 + 2 };
                const type = Math.random() < 0.15 ? '0' : (Math.floor(Math.random() * 9) + 1).toString();
                const color = type === '0' ? '#34495e' : this.colors[Math.floor(Math.random() * this.colors.length)];
                this.gameObjects.push(new Fruit(x, y, radius, color, velocity, type));
            }

            handleGesture(gesture) {
                let hit = false;
                for (let i = this.gameObjects.length - 1; i >= 0; i--) {
                    const fruit = this.gameObjects[i];
                    if (fruit.text === gesture) {
                        hit = true;
                        if (gesture === '0') {
                            this.score = Math.max(0, this.score - 10);
                            actionFeedbackEl.textContent = 'ğŸ’¥ ç‚¸å¼¹! -10åˆ†!';
                            actionFeedbackEl.style.color = 'var(--error-color)';
                            this.createExplosion(fruit.x, fruit.y, '#7f8c8d');
                        } else {
                            this.score += 5;
                            actionFeedbackEl.textContent = `âœ… å‡»ä¸­! +5åˆ†!`;
                            actionFeedbackEl.style.color = 'var(--success-color)';
                            this.createExplosion(fruit.x, fruit.y, fruit.color);
                        }
                        this.gameObjects.splice(i, 1);
                        break; // æ¯æ¬¡åªå‡»ä¸­ä¸€ä¸ªç›®æ ‡
                    }
                }
                if (!hit) {
                    actionFeedbackEl.textContent = `âŒ æœªå‡»ä¸­!`;
                    actionFeedbackEl.style.color = 'var(--info-color)';
                }
            }
            
            endGame() {
                if(!this.gameTimerId) return; // é˜²æ­¢é‡å¤è°ƒç”¨
                actionFeedbackEl.textContent = `æ—¶é—´åˆ°ï¼æœ€ç»ˆå¾—åˆ†: ${this.score}`;
                this.stop();
                setTimeout(this.onGameOver, 2000);
            }
        }
        
        // ... MagicSpellGame class (æ— é‡å¤§bugï¼Œä¿æŒåŸæ ·) ...
        class MagicSpellGame extends GameEngine {
            constructor(canvas, onGameOver) {
                super(canvas, onGameOver);
                this.sequence = []; this.sequenceTimeout = null;
                this.spells = {
                    '7-3-5': { name: 'ğŸ”¥ ç«çƒæœ¯', effect: this.castFireball.bind(this) },
                    '1-2-3-4': { name: 'ğŸ›¡ï¸ æŠ¤ç›¾æœ¯', effect: this.castShield.bind(this) },
                    '8-8-8': { name: 'âš¡ï¸ é—ªç”µé£æš´', effect: this.castLightning.bind(this) }
                };
            }
            draw() {
                super.draw();
                this.ctx.fillStyle = 'white'; this.ctx.font = 'bold 40px Arial';
                this.ctx.textAlign = 'center'; this.ctx.fillText(this.sequence.join(' - '), this.canvas.width / 2, this.canvas.height - 50);
            }
            handleGesture(gesture) {
                clearTimeout(this.sequenceTimeout); this.sequence.push(gesture);
                const seqStr = this.sequence.join('-');
                if (this.spells[seqStr]) {
                    actionFeedbackEl.textContent = `âœ¨ æ–½æ³•æˆåŠŸ: ${this.spells[seqStr].name}`;
                    actionFeedbackEl.style.color = 'var(--success-color)';
                    this.spells[seqStr].effect(); this.sequence = [];
                } else {
                    actionFeedbackEl.textContent = '...ç»§ç»­è¾“å…¥å’’è¯­...';
                    actionFeedbackEl.style.color = 'var(--text-color)';
                    this.sequenceTimeout = setTimeout(() => { this.sequence = []; }, 3000);
                }
            }
            castFireball() {
                const x = this.canvas.width / 2; const y = this.canvas.height / 2;
                for (let i = 0; i < 100; i++) {
                    const angle = Math.random() * Math.PI * 2; const speed = Math.random() * 8 + 2;
                    const velocity = { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed };
                    const color = ['#e74c3c', '#f39c12', '#f1c40f'][Math.floor(Math.random() * 3)];
                    this.particles.push(new Particle(x, y, color, Math.random() * 5 + 2, velocity));
                }
            }
            castShield() {
                const centerX = this.canvas.width / 2; const centerY = this.canvas.height / 2;
                const radius = 150;
                 for (let i = 0; i < 150; i++) {
                    const angle = (i / 150) * Math.PI * 2;
                    const x = centerX + Math.cos(angle) * radius; const y = centerY + Math.sin(angle) * radius;
                    const velocity = { x: (x - centerX) * 0.1, y: (y - centerY) * 0.1 };
                    this.particles.push(new Particle(x, y, '#3498db', Math.random() * 4 + 1, velocity));
                }
            }
            castLightning() {
                for (let i = 0; i < 5; i++) { this.createLightningBolt(Math.random() * this.canvas.width, 0); }
            }
            createLightningBolt(x, y) {
                let lastX = x; let lastY = y;
                while(lastY < this.canvas.height) {
                    const nextX = lastX + (Math.random() - 0.5) * 40; const nextY = lastY + Math.random() * 20 + 10;
                    this.particles.push(new Particle(nextX, nextY, '#ecf0f1', Math.random() * 3 + 1, {x:0, y:0}));
                    lastX = nextX; lastY = nextY;
                }
            }
        }
        
        // --- Initial Connect ---
        connect();
    });
    </script>
</body>
</html>